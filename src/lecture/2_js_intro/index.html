<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Hooray! Javascript!</title>
	<meta name="description" content="{LECTURE DESCRIPTION}">
	<meta name="keywords" content="{LECTURE KEYWORDS}">
	<meta name="author" content="Karpovich Pavel">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0 ">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? "../../css/print/pdf.css" : "../../css/print/paper.css";
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Веб программирование. Фронтенд</h1>
                    <h3>JavaScript</h3>
					<div>
						<p style="display: inline-block;">
							Карпович Павел / 
						</p>
						<a href="https://github.com/tgjmjgj" class="icon-button github">
							<i class="fa fa-github"></i><span></span>
						</a>
						<a href="https://facebook.com/paradox7master" class="icon-button facebook">
							<i class="fa fa-facebook"></i><span></span>
						</a>
					</div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<img src="img/swamp.jpg">
			</section>
			<section>
				<section>
					<h2>Начало</h2>
					<p>
						Через некоторое время после возникновения и распространения веба, возникла идея придать 
						веб-страницам динамики и интерактивности - дать возможность пользователю
						как-либо взаимодействовать с документом.
					</p>
					<p>
						И тогда, в 1995 году, разработанный за 10 дней, появился JavaScript.
					</p>
					<p>
						У JS была тяжелая история. В то время, никто и не предполагал, насколько разовьётся и станет
						распространённым веб. Изначально, JS был разработан только для того, чтобы обеспечивать
						возможность обработки пользовательского взаимодействия (нажатие на кнопочки) и написания
						простейших алгоритмов.
					</p>
				</section>
				<section>
					<h2>Трудное детство</h2>
					<p>
						Когда произошел взрыв популярности и веб технологии стали распространяться с бешенной скоростью,
						первоначальный JavaScript был не готов к этому, и его пришлось кардинально менять.
						За последние 10 лет JavaScript превратился в совершенно другой язык программирования.
					</p>
					<p>
						Но из соображений обратной совместимости JS не был переделан заново, а дополнен новой функциональностью.
						В итоге получилось так, что сейчас в языке содержится огромное количество устаревших
						конструкций, не использующихся элементов, костылей и просто странных вещей.
					</p>
				</section>
			</section>
			<section>
				<section>
					<h2>ECMA Script</h2>
					<p>
						Вообще, мы будем изучать <b>браузерный JavaScript</b>. Тот JS, средой выполнения которого
						является браузер.
					</p>
					<p>
						Но, в принципе, JavaScript может быть и другим. Например, NodeJS - самая распространённая 
						серверная версия JS.  
					</p>
					<p>
						Сам по себе, JavaScript - это просто язык, т.е. установленный набор команд (синтаксис).
						А где он будет выполняться, это уже другой вопрос, - зависит от реализации.
					</p>
					<p>
						Синтаксис языка JavaScript задаётся спецификацией <span class="purple">ECMA Script</span>.
					</p>
				</section>
			</section>
			<section>
				<h2>Just javascript</h2>
				<img src="img/thanks_javascript.png">
			</section>
			<section>
				<section>
					<h2>Многообразие браузеров</h2>
					<p>
						Каждый браузерный движок отображает HTML и CSS по своему.
					</p>
					<p>
						И каждый движок JavaScript выполняет JS по своему.
					</p>
					<p>
						Конечно, все браузерные движки должны соответствовать спецификациям HTML5, CSS3, и многим другим
						общепринятым соглашениям.
					</p>
					<p>
						В случае с JS, его движки должны соответствовать спецификации ECMA Script.
					</p>
				</section>
				<section>
					<h2>Многообразие проблем</h2>
					<p>
						Но на практике, это не всегда бывает так, как должно.
					</p>
					<p>
						В одном движке спецификация может не соблюдаться, в другом движке быть какой-нибудь баг.
					</p>
					<p>
						Помимо спецификации, в каждом движке содержится свой собственный уникальный набор
						функциональности и API, расширяющий возможности спецификаций.
					</p>
					<p>
						Так, какое-то действие в одном браузере может совершаться по-своему, во втором по спецификации,
						а в третьем вообще не поддерживаться.
					</p>
					<p>
						И это касается не только JS с JavaScript движками, но и HTML и CSS с браузерными движками.
					</p>
					<p>
						Конечно, всё это редкие случаи, касающиеся каких-либо продвинутых возможностей. Базовые
						вещи работают везде одинаково.
					</p>
				</section>
				<section>
					<h2>Версии браузеров</h2>
					<p>
						И это мы ещё не учитывали версии браузеров. Ежемесячно, а то и чаще, для браузеров выходят
						обновления и появляются новые версии с дополнительной функциональностью движков.
					</p>
					<p>
						Это значит, что какая-то функциональность будет работать в новых версиях браузеров, а в более
						старых работать не будет, или будет, но некорректно.
					</p>
					<p>
						А не все пользователи своевременно обновляют браузеры, ой как не все.
					</p>
				</section>
				<section>
					<h2>Поддержка</h2>
					<p>
						И поддержка более старых версий браузеров для своего приложения может стать настоящим кошмаром.
					</p>
					<p>
						Даже поддержка нескольких браузеров может привести к серьёзным трудностям 
						(Internet Explorer - вообще отдельная история)
					</p>
					<p>
						А поддержка старых версий нескольких браузеров может и вовсе привести к необходимости полной
						переработки кода и использованию целого вагона костылей.
					</p>
					<p>
						Информацию о том, что и где поддерживается, нужно смотреть на сайте 
						<a hraf="https://caniuse.com/">https://caniuse.com/</a>
					</p>
				</section>
				<section>
					<h2>Поддержка</h2>
					<p>
						Какие браузеры и версии поддерживать зависит в общем от строгости требований и целевой
						аудитории.
					</p>
					<p>
						Любой неподдерживаемый браузер уменьшает количество потенциальных пользователей, поэтому
						чем шире поддержка, тем лучше.
					</p>
					<small>
						Если ваш сайт корректно работает в IE7 или ниже, можете идти за медалью.
					</small>
				</section>
				<section>
					<h2>Спасение</h2>
					<p>
						На самом деле, такие трудности с поддержкой старых версий браузеров,
						в большинстве случаев, уже остались в истории. Потому
						что сейчас есть <span class="purple">Babel</span>.
					</p>
					<iframe width="560" height="315" src="https://www.youtube.com/embed/40abpedBKK8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				</section>
			</section>
			<section>
				<section>
					<h3>Суть</h3>
					<blockquote>
						В общем, никто не ожидал от веба многого. JS задумывался как простенький язык
						для обработки маленьких скриптов.
					</blockquote>
					<p>
						А оно вон как сложилось.
					</p>
				</section>
				<section>
					<h2>Темп развития</h2>
					<p>
						Все проблемы веб приложений связаны именно с незапланированным стремительным ростом.
					</p>
					<p>
						Сейчас всё идёт в веб. Большинство современных программных разработок в первую 
						очередь направлены на веб.
						Веб-сайты компаний появляются раньше, чем компании создаются.
						Все сервисы расположены в вебе, у любого проекта есть свой веб сайт.
						Да даже у каждого человека (почти) в ИТ есть свой веб сайт или несколько.
					</p>
					<p>
						Поэтому за последний 10 лет JavaScript стал самым популярным языком программирования в мире.
					</p>
				</section>
				<section>
					<h2>Статистика Stack Overflow 2018</h2>
					<img src="img/js_popularity_so.png">
					<p>
						<a href="https://insights.stackoverflow.com/survey/2018/">
							Популярность языков программирования по использованию среди опрошенных пользователей.
						</a>
					</p>
				</section>
				<section>
					<h2>Статистика GitHub 2018</h2>
					<img src="img/js_octoverse_stat.jpg">
					<p>
						<a href="https://octoverse.github.com/">
							Популярность языков программирования среди репозиториев GitHub.
						</a>
					</p>
				</section>
				<section>
					<h2>Статистика GitHub 2018</h2>
					<img src="img/js_pullrequests_so.png">
					<p>
						Статистика по pull request на GitHub.
					</p>
				</section>
				<section>
					<h2>Javascript уже в вашем тостере</h2>
					<img src="img/javascript.jpg">
				</section>
			</section>
			<section>
				<section>
					<h2>Итак,</h2>
					<h1>JavaScript</h1>
				</section>
				<section>
					<h2>Определение</h2>
					<blockquote>
						<span class="blue">JavaScript (JS)</span> - высокоуровневый интерпретируемый язык программирования
						общего назначения с динамической слабой типизацией, прототипной системой наследования и 
						событийно-ориентированной архитектурой.
					</blockquote>
					<p>
						Во как.
					</p>
					<p>
						Поскольку мы изучаем именно браузерный JS, то можно добавить, что ещё он является скриптовым
						языком программирования.
					</p>
				</section>
				<section>
					<h2>Скрипты</h2>
					<p>
						Браузерный JS - скриптовый язык программирования.
					</p>
					<p>
						Программы, написанные на JS, называются <span class="blue">скрипты</span>.
					</p>
					<p>
						<span class="blue">Скрипт</span> - вспомогательная программа для другой программы.
						Скрип не выполняется самостоятельно, он привязан к какому-то другому процессу и вызывается по
						потребности.
					</p>
					<p>
						В отличие от обычных программ, скрипт не работает всё время. Он вызывается в определённый
						момент, выполняется и завершается. То, что работает всё время - это другой процесс, 
						родительский для скрипта. В случае с JS - это <span class="purple">вкладка браузера</span> 
						(на самом деле всё происходит в одном процессе, но суть та же).
					</p>
				</section>
				<section>
					<h2>Интерпретация</h2>
					<p>
						JS - интерпретируемый язык программирования.
					</p>
					<p>
						Он передаётся с сервера в браузер в виде исходного кода, как текстовый файл. Т.е. здесь
						отсутствует этап компиляции - вернее сказать, компиляция совмещена с выполнением. 
					</p>
					<p>
						Это наглядно видно при работе с JS в браузерной консоли. Код выполняется построчно,
						по мере его поступления, т.е. ввода, причём весь контекст сохраняется в памяти.
					</p>
					<p>
						Это и называется интерпретацией.
					</p>
				</section>
				<section>
					<h2>Динамическая слабая типизация</h2>
					<p>
						Это проще охарактеризовать, как принципиальное отсутствие типизации)
					</p>
					<p>
						Переменная в JS - это просто коробка, в которую можно положить что угодно и
						заменить на что угодно. 
					</p>
					<pre>
						<code class="js">
let a = 42;    // сейчас a - это number
a = 'bar'; // теперь string
a = true;  // а теперь boolean
						</code>
					</pre>
				</section>
				<section>
					<h2>Событийно ориентированная архитектура</h2>
					<p>
						За счёт того, что JS выполняется в рамках одного процесса вкладки браузера, вместе с разбором и 
						визуализацией HTML страницы, для него была выбрана очень необычная модель выполнения 
						(event-driven architecture), не похожая на другие языки программирования.
					</p>
					<p>
						Её мы подробно рассмотрим в следующей лекции.
					</p>
				</section>
				<section>
					<h2>Прототипная система наследования</h2>
					<p>
						JS - не объектно-ориентированный язык программирования. По крайней мере, он создавался не таким.
						Изначально в нём была реализована прототипно-ориентированная парадигма программирования.
					</p>
					<p>
						В 2009 году, поверх прототипно-ориентированной модели, в язык были добавлены классические конструкции
						для ООП, такие как классы, наследование классов, геттеры-сеттеры и т.д.
					</p>
					<p>
						На самом деле это довольно интересно, так что можно самостоятельно изучить прототипную модель.
					</p>
				</section>
			</section>
			<section>
				<h2>Быстрый экскурс в синтаксис</h2>
			</section>
			<section>
				<h2>Суть JS</h2>
				<p>
					Вообще, можно сказать, что всё из чего состоит JavaScript - это переменные, функции и объекты.
				</p>
			</section>
			<section>
				<section>
					<h2>Переменные</h2>
					<p>
						Как мы уже сказали, переменные в JS - это просто контейнер, в который можно
						положить что угодно: любой тип, любой объект.
					</p>
					<p>
						Есть 3 разрешённых способа объявить переменную в JS. С помощью ключевых слов:
					</p>
					<ul>
						<li>var</li>
						<li>let</li>
						<li>const</li>
					</ul>
				</section>
				<section>
					<h2>Устаревший var</h2>
					<p>
						Ключевое слово <span class="blue">var</span> было в языке с самого начала, и сейчас
						считается устаревшим, и крайне не рекомендуется к использованию. На работе за такое
						по рукам бить будут.
					</p>
					<p>
						Переменные, объявленные с помощью слова var, не подчиняются никаким законам и нарушают
						все правила программирования.
					</p>
				</section>
				<section>
					<h3>Демонстрация var</h3>
					<pre>
						<code class="js">
a = 4;
if ("2" == 4) {

	var a = 2;
	console.log("yes");

} else {

	console.log("no");

}

a++;
console.log(a);		// 3
var a = 15;
console.log(a);		// 15
						</code>
					</pre>
				</section>
				<section>
					<h2>let для переменных</h2>
					<p>
						Для обычных переменных нужно использовать ключевое слово <span class="blue">let</span>.
					</p>
					<p>
						let переменные были введены, чтобы заменить и исправить кривые var переменные,
						т.е. они уже ведут себя как нормальные переменные, из других языков программирования:
						существуют только в рамках своего контекста и не могут быть повторно инициализированы
						(в рамках одного контекста).
					</p>
					<p>
						Но это не сильно помогло=)
					</p>
				</section>
				<section>
					<h3>Демонстрация let</h3>
					<pre>
						<code class="js">
let i = 2;
console.log(i);		// 2
//let i = 12;		// error
if (i == 2) {

	//console.log(i); // error
	let i = 30;
	console.log(i);		// 30
	if (i == 30) {

		//console.log(i); // error
		let i = 400;
		console.log(i);		// 400

	}
	console.log(i);		// 30

}
console.log(i);		// 2
						</code>
					</pre>
					<p>
						P.S. Кому интересно почему это так работает, можно погуглить в сторону лексического
						окружения, или lexical environment.
					</p>
				</section>
				<section>
					<h2>Константы const</h2>
					<p>
						Переменные, объявленные с помощью слова <span class="blue">const</span>
						ведут себя также, как let переменные, с одной особенностью: ссылочная иммутабельность.
					</p>
					<p>
						Это значит, что назначенный такой переменной объект <u>нельзя переназначить</u>.
						Если это объект, изменять его свойства можно. Единственное ограничение - невозможность
						присвоить другое значение самой переменной. Т.е. это просто константный указатель.
					</p>
					<p>
						Из названия понятно, что такие переменные используются для объявления констант.
					</p>
				</section>
				<section>
					<h3>Демонстрация const</h3>
					<pre>
						<code class="js">
const i = 2;
//i = "khe";		//error 
//i++;      //error
const arr = [1];
console.log(arr);       // [1]
arr.push(2);
console.log(arr);       // [1, 2]
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Всё равно равно</h2>
					<pre>
						<code class="js">
let a = 2, b = 3;
let v1 = (a = b);
let v2 = (a == b);
let v3 = (a === b);
						</code>
					</pre>
				</section>
				<section>
					<h2>Сравнения</h2>
					<p>
						В JS 2 оператора сравнения на равенство/неравенство:
					</p>
					<ul>
						<li>Через двойное равно</li>
						<li>Через тройное равно</li>
					</ul>
					<p>
						Они отличаются по <u>строгости сравнения</u>.
					</p>
					<p>
						Двойное равенство - это свободное сравнение, допускающее преобразование типов.
					</p>
					<p>
						Тройное равенство - это строгое сравнение, не выполняющее преобразования.
					</p>
				</section>
				<section>
					<h2>Демонстрация сравнений</h2>
					<pre>
						<code class="js">
1 == "1";		// true
1 === "1";		// false

'0' == false;		// true
'0' === false;		// false

[] != true;			// true
[] !== true;		// true
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Типы данных</h2>
					<p>
						Как ни удивительно, но типы данных в JS всё-таки есть,
						и их 8 штук (инсайдерская информация!):
					</p>
					<p>
						7 встроенных иммутабельных типов (примитивы):
					</p>
					<ul>
						<li>Number</li>
						<li>String</li>
						<li>Boolean</li>
						<li>Null</li>
						<li>Undefined</li>
						<li>Symbol</li>
						<li>BigInt</li>
					</ul>
					<p>
						И один мега-тип Object. Object в JS это отдельная история, и когда-нибудь мы о ней поговорим.
					</p>
				</section>
				<section>
					<h2>undefined, null и NaN</h2>
					<p>
						В JS есть 3 основных значения, которые означают, что что-то пошло не так.
					</p>
					<p>
						<span class="blue">undefined</span> и <span class="blue">null</span> - одновременно
						примитивные типы и единственные их значения (не спрашивайте, как это может быть).
					</p>
					<p>
						undefined используется как значение для переменных, которым не было назначено никакое значение.
					</p>
					<p>
						null используется для обозначения ошибки, неправильного результата, отсутствия значения.
					</p>
					<p>
						undefined не принято назначать самостоятельно. Для целей разработчика нужно использовать значение null.
					</p>
				</section>
				<section>
					<h3>Немножко JS-а</h3>
					<pre>
						<code class="js">
let a;		// a === undefined

let b = null;
						</code>
					</pre>
					<pre>
						<code class="js">
undefined == null;		// true
undefined === null;		// false
!undefined === !null;		// true
						</code>
					</pre>
					<p>
						Пора привыкать к такому.
					</p>
				</section>
				<section>
					<h2>На-нна-нна-нна!</h2>
					<p>
						Значение <span class="blue">NaN</span> можно получить в результате математических действий над
						некорректными операндами, и, соответственно, оно обозначает результат некорректной операции над числами.
					</p>
					<p>
						NaN не является отдельным типом, NaN - это число (тип number).
					</p>
					<p>
						А знаете что ещё?
					</p>
					<pre>
						<code class="js">
NaN == NaN;			// false
NaN === NaN;		// false
						</code>
					</pre>
					<p>
						NaN не равен NaN. Не равен самому себе. И это число.
					</p>
				</section>
				<section>
					<img src="img/nan.jpg">
				</section>
			</section>
			<section>
				<section>
					<h2>Функции в JS</h2>
					<p>
						Функции описываются с помощью ключевого слова <span class="blue">function</span>,
						или через лямбда-выражение. Только в JS функции, записанные обычным образом, и записанные
						при помощи лямбда выражения работают по разному. Но об этом попозже.
					</p>
					<pre>
						<code class="js">
function func_name(arg1, arg2, arg3) {
	return arg2 + arg3;
}
						</code>
					</pre>
					<p>
						Функции могут принимать параметры, а могут и не принимать, могут возвращать значение, а могут
						и не возвращать.
					</p>
				</section>
				<section>
					<h3>Примеры функций</h3>
					<pre>
						<code class="js">
function f1() {
	console.log("empty");
}

function f2() {
	return 1.3213;
}

function f3(a, b, c) {
	let res = a + b + c;
	console.log(res);
	return res;
}
let r1 = f3();  // NaN
let r2 = f3(3); // NaN
let r3 = f3(4, "5"); // 45undefined
let r4 = f3(1, 2, 3); // 6
let r5 = f3(1, 2, 3, 4); // 6 
						</code>
					</pre>
				</section>
				<section>
					<h3>JS всё равно</h3>
					<p>
						Как вы видите, JavaScript-у наплевать, какие аргументы описаны у функции, какие
						и сколько аргументов вы в неё передаёте при вызове.
					</p>
					<p>
						Аргументы, которые не были переданы будут просто равны undefined.
					</p>
					<p>
						И если попытаться принять значение, когда у функции нет return-а, то будет
						получено значение undefined.
					</p>
				</section>
				<section>
					<img src="img/welcome_js.jpg">
				</section>
				<section>
					<h2>Функциональное выражение</h2>
					<p>
						Синтаксис описания функции, описанный выше, называется
						<span class="purple">объявлением функции</span>.
 					</p>
					<p>
						Но функции можно объявлять и по-другому, через переменные:
					</p>
					<pre>
						<code class="js">
let func1 = function (arg1, arg2) {

	if (typeof arg1 === "number" && typeof arg2 === "number") {
		return arg1 / arg2;
	} else {
		console.log("arg1 or arg2 is not numbers!");
	}

}
func1(2, 5);
						</code>
					</pre>
					<p>
						Такой способ создания функций называется <span class="purple">функциональным выражением</span>.
					</p>
				</section>
				<section>
					<h2>Лямбда-выражения</h2>

				</section>
			</section>
			<section>
				<section>
					<h2>Object в JS</h2>
					<blockquote>
						Объекты занимают ключевое место в JavaScript. Практически всё в языке
						построено вокруг объектов.
					</blockquote>
					<p>
						Даже функция в JS - это особый вид объекта.
					</p>
				</section>
				<section>
					<h2>Объект</h2>
					<blockquote>
						Объект в JS - это коллекция пар ключ-значение, или <span class="purple">ассоциативный массив</span>.
					</blockquote>
					<p>
						Если в сильно типизированных статических языках программирования структура
						объекта строго описывалась классами, то в JS у объектов нет чёткой структуры,
						свойства можно добавлять и удалять динамически, как элементы списка.
					</p>
					<p>
						Поэтому нет и самостоятельных типов-классов, а только один Object: из
						любого объекта можно слепить какую угодно структуру.
					</p>
				</section>
				<section>
					<h2>Литеральный синтаксис объектов</h2>
					<p>
						Для создания объектов в JS используется специальный синтаксис: фигурные скобки,
						и внутри них перечисленные через запятую пары "ключ : значение".
					</p>
					<pre>
						<code class="js">
let obj_name = {
	property1 : value1,
	property2 : value2,
	property3 : value3
}
						</code>
					</pre>
					<p>
						В качестве ключа, т.е. имени свойства, могут использоваться любые строки. Записывать
						их можно как в кавычках, так и без.
					</p>
				</section>
				<section>
					<h3>Примеры создания объектов</h3>
					<pre>
						<code class="js">
let auto = {
	brand: 'BMW',
	model: '2019 BMW i8 Roadster AWD',
	price: '$139,000',
	color: 'white',
	engine: 'I3'
};

let student1 = {
	'name': 'Markus Zaynits',
	age: 24,
	faculty: "MITOC",
	"semester": 4,
	expelled: false
}

let c1 = { name: "Larry Borrow", phone: "+1 839 829 12 92" };

function call_joseph(num) {
	console.log("I'm calling Joseph");
	return true;
}

let phone_book = { 
	contact1: c1,
	contact2: { name: "Marry", phone: "+ 327 82 918 82 15"},
	contact3: { name: "Leonard Berkley", phone: "+23 38 98 12 20"},
	call: call_josheph 
}

						</code>
					</pre>
				</section>
				<section>
					<h2>Доступ к свойствам объектов</h2>
					<p>
						Объекты JS поддерживают 2 формы записи для доступа к свойствам: через точку и через квадратные скобки.
					</p>
					<pre>
						<code class="js">
myobj.a = 2;
myobj.b = "grrr";
console.log(myobj.c);
						</code>
					</pre>
					<pre>
						<code class="js">
myobj["a"] = 2;
myobj["b"] = "grr";
console.log(myobj["c"]);
						</code>
					</pre>
					<p>
						Когда это возможно, рекомендуется использовать первую форму записи, через точку.
					</p>
				</section>
				<section>
					<h2>Свойства в JS</h2>
					<p>
						Ключом для свойства объекта может выступать любая строка. Абсолютно.
					</p>
					<pre>
						<code class="js">
let obj = {
	"😘": "emoji",
	"!": "character",
	"": "empty string",
	".": 404,
	"∰": "no...",
	"✪✪✪✪": "stop it..",
	"☝ஔ☔😱": "please"
}

console.log(obj["😘"]);
console.log(obj["!"]);
obj[""] = NaN;
obj["."] = obj.wwwwwwww;
console.log(obj["∰"]);
console.log(obj["✪✪✪✪"]);
console.log(obj["☝💩🤡ஔ☔😱"] + " " + obj["☝💩🤡ஔ☔😱"]);

						</code>
					</pre>
				</section>
				<section>
					<h2>Обращение к свойствам, которых нет</h2>
					<p>
						В JS можно обращаться к любым свойствам объекта. Даже если их нет.
					</p>
					<p>
						Обращение к свойству, которое никогда раньше не использовалось и не инициализировалось,
						вернёт undefined.
					</p>
					<pre>
						<code class="js">
let bj = {};
console.log(bj.p);		// undefined
console.log(bj.ee);		// undefined
let int = bj.num;		// int === undefined
						</code>
					</pre>
				</section>
				<section>
					<h2>Добавление свойств</h2>
					<p>
						Ну а чтобы добавить в объект новое свойство, нужно просто присвоить значение
						по новому ключу.
					</p>
					<pre>
						<code class="js">
let pers = {};
console.log(pers);		// { }
pers.name = "Nick";
console.log(pers);		// { name: "Nick" }
pers.age = 25;
console.log(pers);		// { name: "Nick", age: 25 }
pers.weight = 82;
pers.height = 175;
console.log(pers);		// { name: "Nick", age: 25, weight: 82, height: 175 }
						</code>
					</pre>
				</section>
				<section>
					<h3>Особенность обращения через квадратные скобки</h3>
					<p>
						У обращения к свойствам через квадратные скобки есть одно преимущество: возможность
						использования переменных в качестве ключа.
					</p>
					<pre>
						<code class="js">
let obj = { a: 1, b: 2, c: 3, d: 4 };
let prop = "a";
obj[prop] = 10;
prop = "b";
obj[prop] = 20;
console.log(obj);	// { a: 10, b: 20, c: 3, d: 4 } 
						</code>
					</pre>
					<p>
						Иногда это позволяет создавать очень хитрые алгоритмы.
					</p>
				</section>
				<section>
					<h2>Удаление свойств</h2>
					<p>
						Для полного удаления свойства у объект существует оператор <span class="blue">delete</span>.
					</p>
					<pre>
						<code class="js">
let shape = { color: "green", x: 24, y: 75, z: 43 };
delete shape.z;
delete shape["y"];
console.log(shape);		// { color: "green", x: 24 }
						</code>
					</pre>
					<p>
						Но он работает очень медленно и использовать его не рекомендуется. Вместо этого
						зачастую можно обойтись присвоением ненужному свойству значения <span class="blue">undefined</span>.
					</p>
					<pre>
						<code class="js">
let shape = { color: "green", x: 24, y: 75, z: 43 };
shape.z = undefined;
shape["y"] = undefined;
console.log(shape);		// { color: "green", x: 24, y: undefined, z: undefined }
						</code>
					</pre>
				</section>
				<section>
					<h2>Функции как объекты</h2>
					<p>
						Функция в JS это тоже объект. Который просто хранит записанный в ней код в виде текста
						как свойство объекта. С единственный отличием от других объектов, что он может быть вызван.
					</p>
					<p>
						Поэтому всё, что было сказано об объектах, в JS применимо и к функциям.
					</p>
					<p>
						Т.е. у функции есть свойства, и их можно свободно добавлять/убирать:
					</p>
					<pre>
						<code class="js">
function highway_to_js() {
	console.log("Welcome, buddy!");
	return "Nope";
}

highway_to_js.secret = "run";

highway_to_js();
console.log(highway_to_js.secret);
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Встроенные объекты</h1>
			</section>
			<section>
				<section>
					<h2>Встроенные объекты. Массивы</h2>
					<p>
						В JS есть глобальный объект <span class="purple">Array</span>, который используется для создания
						массивов.
					</p>
					<p>
						Массив здесь - это тоже подвид объекта. Т.е. набор пар ключ-значение, где в качестве ключа используются
						числа, начиная с 0. И получается, что это выглядить как обычный массив из других языков программирования.
					</p>
					<p>
						В массиве одновременно могут быть любые элементы, никакой типизации нет.
					</p>
				</section>
				<section>
					<h2>Создание массива</h2>
					<p>
						Массив можно создавать с помощью класса Array и вызова конструктора:
					</p>
					<pre>
						<code class="js">
let arr0 = new Array();
let arr1 = new Array("str1", null, "str2", {a: 32}, "str3", 23, 54.434, false);
let arr2 = new Array(10);
						</code>
					</pre>
					<p>
						Но гораздо удобнее использовать встроенный синтаксис литералов массива: список значений,
						взятый в квадратные скобки.
					</p>
					<pre>
						<code class="js">
let arr0 = [];
let arr1 = ["str1", null, "str2", {a: 32}, "str3", 23, 54.434, false];
let arr2 = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
						</code>
					</pre>
				</section>
				<section>
					<h2>Массив как объект</h2>
					<p>
						Поскольку массив это объект, с его элементами можно работать как со свойствами объекта.
					</p>
					<p>
						Но так делать не рекомендуется, потому что это ломает внутреннюю логику его работы как массива.
					</p>
					<p>
						Например, свойство <span class="purple">length</span> у объекта массива всегда равно значению
						его максимального числового ключа - 1.
					</p>
					<pre>
						<code class="js">
let arr = ["t", "e"];
arr[10000000] = "ы";
console.log(arr.length);			// 9999999
						</code>
					</pre>
					<p>
						Добавили один элемент, увеличили размер массива на 10 миллионов. Профит!
					</p>
				</section>
				<section>
					<h2>Добавление элементов в массив</h2>
					<p>
						Правильно добавлять элементы в массив нужно с помощью встроенных в объект методов. 
					</p>
					<ul>
						<li>Метод <span class="purple">unshift</span> - добавление в начало массива</li>
						<li>Метод <span class="purple">push</span> - добавление в конец массива</li>
						<li>Метод <span class="purple">splice</span> - добавление в определённую позицию массива</li>
					</ul>
					<p>
						Все эти методы могут добавлять любое количество элементов за раз - т.е. столько, сколько в них
						передать парамектров.
					</p>
				</section>
				<section>
					<h3>Примеры добавления</h3>
					<pre>
						<code class="js">
let arr1 = [1, 2, 3];
arr1.unshift("a");					// ["a", 1, 2, 3]
arr1.unshift("b", "c", "d");				// ["b", "c", "d", "a", 1, 2, 3]

let arr2 = [true, false, null];
arr2.push(2);						// [true, false, null, 2]
arr2.push("o", "oop", arr1);				// [true, false, null, 2, "o", "oop", ["b", "c", "d", "a", 1, 2, 3]]

let arr3 = ["Pol", "Roger", "Tom"];
arr3.splice(1, 0, "Nolan");				// ["Pol", "Nolan", "Roger", "Tom"]
arr3.splice(2, 0, "Mickey", "Bred", "Sergio");		// ["Pol", "Nolan", "Mickey", "Bred", "Sergio", "Roger", "Tom"]
						</code>
					</pre>
				</section>
				<section>
					<h2>Удаление элементов из массива</h2>
					<p>
						С удалением всё по аналогии, как и с добавлением - 3 варианта методов.
					</p>
					<ul>
						<li>Метод <span class="purple">shift</span> - удаление из начала массива</li>
						<li>Метод <span class="purple">pop</span> - удаление из конец массива</li>
						<li>Метод <span class="purple">splice</span> - удаление из определённой позиции массива</li>
					</ul>
					<p>
						С помощью метода splice можно удалить указанное количество подряд идущих элементов.
						Shift и pop удаляют только по одному за раз.
					</p>
					<p>
						Эти методы возвращают удалённые из массива значения.
					</p>
				</section>
				<section>
					<h3>Примеры удаления</h3>
					<pre>
						<code class="js">
let people = [
		{ name: "George", city: "London" }, 
		{ name: "Ralf", city: "Copenhagen" }, 
		{ name: "John", age: 33 }, 
		{ id: "Golden Eagle", location: "Russia" },
		{ name: "Melissa", city: "Cambridge" }
	];

people.shift();				// delete George
let man = people.shift();		// delete Ralf
console.log(man);			// { name: "Ralf", city: "Copenhagen" }
console.log(people);			// [{ name: "John", age: 33 }, { id: "Golden Eagle", location: "Russia" }, { name: "Melissa", city: "Cambridge" }]
			
people.pop();				// delete Melissa
people.pop();				// delete Golden Eagle
console.log(people);			// [{ name: "John", age: 33 }]

let mas = [1, 2, 3, 4, 5, 6, 7, 8, 9];
mas.splice(2, 1);			// [1, 2, 4, 5, 6, 7, 8, 9]
let del = mas.splice(4, 3);		// [1, 2, 4, 5, 9]
console.log(del);			// [6, 7, 8]
						</code>
					</pre>
				</section>
				<section>
					<h2>Методы массива</h2>
					<p>
						В объекте массива содержится большой набор стандартных методов для работы с ним.
					</p>
					<p>
						Важно отметить, что многие методы (и не только в этом объекте) в JS могут работать 
						по-разному, в зависимости от количества и типов переданных в них параметров.
					</p>
					<p>
						Методы массива можно условно разделить на:
					</p>
					<ul>
						<li>Простые методы</li>
						<li>Функциональные методы</li>
					</ul>
				</section>
				<section>
					<h2>Методы массива</h2>
					<p>
						Некоторые методы массива:
					</p>
					<table>
						<tr>
							<td>concat()</td>
							<td>Объединяет несколько массивов в один</td>
						</tr>
						<tr>
							<td>fill()</td>
							<td>Заполняет все элементы массива одним значением</td>
						</tr>
						<tr>
							<td>flat()</td>
							<td>Возвращает новый одномерный массив из массива с подмассивами</td>
						</tr>
						<tr>
							<td>includes()</td>
							<td>Проверяет, содержит ли массив элемент с указанным значением</td>
						</tr>
						<tr>
							<td>indexOf()</td>
							<td>Ищет в массиве индекс первого элемента с указанным значением</td>
						</tr>
						<tr>
							<td>lastIndexOf()</td>
							<td>Тоже самое, только с конца</td>
						</tr>
						<tr>
							<td>reverse()</td>
							<td>Меняет порядок элементов в исходном массиве</td>
						</tr>
						<tr>
							<td>slice()</td>
							<td>Получает подмассив из исходного массива</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Использование</h3>
					<pre>
						<code class="js">
let students = ["Markus", "Elly", "Tim"];
let other = ["Jacky", "Sol", "Regina"];

let all = students.concat(other);
let allAndMore = students.concat(other, "Benjamin", ["Lorenzo", "Grim"]);

allAndMore.fill("Unknown");					// ["Unknown" x9]

let dimArr = [ [[1],[2]], [[[3]]], [4]];
dimArr.flat(3);							// [1, 2, 3, 4]

if (students.includes("Elly")) {

	let indexElly = students.indexOf("Elly"); 
	console.log("Hello Elly! Your index is " + indexElly);

}

all.push("Jacky");
let firstIndex = all.indexOf("Jacky");				// 3
let secondIndex = all.indexOf("Jacky", firstIndex + 1);		// 6

let lastIndex = all.lastIndexOf("Jacky");			// 6

other.reverse();						// ["Regina", "Sol", "Jacky"]

let arr = [0, 5, 2, 7, 6, 2, 1, 75, 37, 1, 22, 10, 3];
arr.sort();				// !!!
console.log(arr);			// [0, 1, 1, 10, 2, 2, 22, 3, 37, 5, 6, 7, 75]

arr.sort((x, y) => x > y);
console.log(arr);			// [0, 1, 1, 2, 2, 3, 5, 6, 7, 10, 22, 37, 75]

let subArray = arr.slice(1, 9);		// [1, 1, 2, 2, 3, 5, 6, 7]
let subArray2 = arr.slice(6);		// [5, 6, 7, 10, 22, 37, 75]
						</code>
					</pre>
				</section>
				<section>
					<h2>Всемогущий метод splice</h2>
					<p>
						Ну, во-первых, методы splice и slice - это 2 разных метода.
					</p>
					<p>
						Метод <span class="purple">splice</span> позволяет удалить любое количество элементов из 
						любого места в массиве, а затем вставить в это место любое количество элементов.
					</p>
					<pre>
						<code class="js">
arr.splice(позиция, сколько_удалять, добавляемые элементы...)
						</code>
					</pre>
					<pre>
						<code class="js">
let animals = ["cow", "cat", "dog", "bear", "tiger"];
let deleted = animals.splice(1);
console.log(animals);					// ["cow"]
console.log(deleted);					// ["cat", "dog", "bear", "tiger"]

deleted.splice(0, 2);					// ["bear", "tiger"]
animals.splice(1, 0, ...deleted);			// ["cow", "bear", "tiger"]
animals.splice(0, 2, "horse", "pig", "elephant");	// ["horse", "pig", "elephant", "tiger"]
						</code>
					</pre>
				</section>
				<section>
					<h2>Функциональные методы массива</h2>
					<p>
						Функциональные методы - методы в стиле функционального программирования, принимающие параметром другую функцию.
					</p>
					<table>
							<tr>
								<td>filter</td>
								<td>Фильтрует элементы массива в соответствии с переданной функцией</td>
							</tr>
							<tr>
								<td>find</td>
								<td>Ищет первый элемент массива, удовлетворяющий условию в переданной функции</td>
							</tr>
							<tr>
								<td>forEach</td>
								<td>Функциональный вариант цикла for, выполняет указанную функцию для каждого элемента</td>
							</tr>
							<tr>
								<td>map</td>
								<td>Создаёт новый массив из старого, выполняя переданную функцию для каждого элемента</td>
							</tr>
							<tr>
								<td>reduce</td>
								<td>Преобразует массив в одно значение в соответствии с переданной функцией</td>
							</tr>
							<tr>
								<td>sort</td>
								<td>Сортирует массив по условию в переданной функции</td>
							</tr>
					</table>
				</section>
			</section>
			<section>
				<h2>Оператор in</h2>
				<p>
					С помощью оператора <span class="blue">in</span> можно проверить, есть ли заданный ключ в указанном объекте.
				</p>
				<pre>
					<code class="js">
let soup = { freshness: 2, taste: 3, name: "borscht", "cook": "Anatoly" };
if ('tast' in soup) {

	console.log("wrong");

} else if ('taste' in soup) {

	console.log("yes!");

}

if (0 in soup === false) {

	console.log("There is no 0");

}
					</code>
				</pre>
			</section>
			<section>
				<img src="img/cry.jpg">
			</section>
			<section>
				<h3>Ресурсы</h3>
				<p>
					P.S. Один из лучших ресурсов по вебу - MDN.
				</p>
				<a href="https://developer.mozilla.org/ru/">Mozilla Developer Network</a>
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x controls"></i>
		</a>
	</aside>
    <aside id="presentable-icon-close">
        <a title="На GitHub" href="https://github.com/tgjmjgj/js">
            <i class="fa fa-times fa-2x controls"></i>
        </a>
    </aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>